# main.py
import os
import asyncio
import datetime
import random
import logging
from contextlib import contextmanager

from dotenv import load_dotenv
load_dotenv()

from sqlalchemy import (
    create_engine, Column, Integer, String, ForeignKey, DateTime, Boolean, Float
)
from sqlalchemy.orm import declarative_base, sessionmaker, relationship

from apscheduler.schedulers.asyncio import AsyncIOScheduler

from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes

# ========== CONFIG ==========
BOT_TOKEN = os.environ.get("BOT_TOKEN", "").strip()
WEBHOOK_BASE_URL = os.environ.get("WEBHOOK_BASE_URL", "").rstrip("/") or None
PORT = int(os.environ.get("PORT", 5000))
DATABASE_URL = os.environ.get("DATABASE_URL", "sqlite:///./dev.db")

# Logging
logging.basicConfig(level=logging.INFO)
log = logging.getLogger("football-manager")

if not BOT_TOKEN:
    log.warning("BOT_TOKEN not set — bot will not start unless provided.")
log.info("WEBHOOK_BASE_URL: %s", WEBHOOK_BASE_URL or "<not set - polling mode>")
log.info("DATABASE_URL: %s", DATABASE_URL)

# ========== DATABASE ==========
Base = declarative_base()
connect_args = {"check_same_thread": False} if DATABASE_URL.startswith("sqlite") else {}
engine = create_engine(DATABASE_URL, connect_args=connect_args, pool_pre_ping=True)
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False, expire_on_commit=False)

@contextmanager
def get_session():
    s = SessionLocal()
    try:
        yield s
    finally:
        s.close()

# ========== MODELS ==========
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    telegram_id = Column(Integer, unique=True, index=True)
    username = Column(String, nullable=True)
    club_id = Column(Integer, ForeignKey("clubs.id"), nullable=True)

class Club(Base):
    __tablename__ = "clubs"
    id = Column(Integer, primary_key=True)
    name = Column(String, unique=True)
    owner_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    budget = Column(Integer, default=1_000_000)
    rating = Column(Float, default=50.0)

class Player(Base):
    __tablename__ = "players"
    id = Column(Integer, primary_key=True)
    name = Column(String)
    club_id = Column(Integer, ForeignKey("clubs.id"), nullable=True)
    rating = Column(Integer, default=50)
    value = Column(Integer, default=100_000)

class Match(Base):
    __tablename__ = "matches"
    id = Column(Integer, primary_key=True)
    home_club_id = Column(Integer)
    away_club_id = Column(Integer)
    scheduled_time = Column(DateTime, default=datetime.datetime.utcnow)
    status = Column(String, default="scheduled")  # scheduled, played, cancelled
    home_goals = Column(Integer, default=0)
    away_goals = Column(Integer, default=0)
    is_friendly = Column(Boolean, default=False)

def create_tables():
    Base.metadata.create_all(bind=engine)

# ========== GAME LOGIC ==========
def compute_club_rating_from_players(players):
    if not players:
        return 30.0
    return sum(p.rating for p in players) / max(1, len(players))

def simulate_match_logic(home_rating, away_rating):
    # Simple probabilistic model with randomness
    diff = home_rating - away_rating
    home_expected = max(0.2, 0.8 + home_rating / 100.0 + diff / 150.0)
    away_expected = max(0.2, 0.8 + away_rating / 100.0 - diff / 150.0)
    # gaussian randomness
    hg = max(0, int(round(random.gauss(home_expected, 1.0))))
    ag = max(0, int(round(random.gauss(away_expected, 1.0))))
    return hg, ag

async def process_scheduled_matches():
    now = datetime.datetime.utcnow()
    with get_session() as s:
        matches = s.query(Match).filter(Match.status == "scheduled", Match.scheduled_time <= now).all()
        for m in matches:
            try:
                home_players = s.query(Player).filter(Player.club_id == m.home_club_id).all()
                away_players = s.query(Player).filter(Player.club_id == m.away_club_id).all()
                home_rating = compute_club_rating_from_players(home_players)
                away_rating = compute_club_rating_from_players(away_players)
                hg, ag = simulate_match_logic(home_rating, away_rating)
                m.home_goals = hg
                m.away_goals = ag
                m.status = "played"
                # rating updates (small)
                delta = 1.0 if hg > ag else (-1.0 if hg < ag else 0.2)
                home_club = s.query(Club).get(m.home_club_id)
                away_club = s.query(Club).get(m.away_club_id)
                if home_club:
                    home_club.rating = max(1.0, (home_club.rating or 50.0) + delta)
                if away_club:
                    away_club.rating = max(1.0, (away_club.rating or 50.0) - delta)
                s.commit()
                log.info("Played match %s: %s %d-%d %s", m.id, m.home_club_id, hg, ag, m.away_club_id)
            except Exception as e:
                log.exception("Error processing match %s: %s", m.id, e)
                s.rollback()

# ========== BOT HANDLERS ==========
async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    with get_session() as s:
        db_user = s.query(User).filter_by(telegram_id=user.id).first()
        if not db_user:
            db_user = User(telegram_id=user.id, username=user.username or user.full_name)
            s.add(db_user)
            s.commit()
    await update.message.reply_text(
        "Привет! Я футбольный менеджер.\n"
        " /register_team <name> — создать клуб\n"
        " /my_team — информация о твоём клубе\n"
        " /clubs — список клубов\n"
        " /challenge <club_id> — сыграть товарищеский матч (немедленно)\n"
        " /schedule — посмотреть запланированные матчи\n"
        " /players <club_id> — показать игроков клуба\n        "
    )

async def register_team_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    name = " ".join(context.args) if context.args else f"{user.username or user.first_name}'s Club"
    with get_session() as s:
        db_user = s.query(User).filter_by(telegram_id=user.id).first()
        if not db_user:
            db_user = User(telegram_id=user.id, username=user.username or user.full_name)
            s.add(db_user)
            s.commit()
        if db_user.club_id:
            await update.message.reply_text("У тебя уже есть клуб.")
            return
        # ensure unique name
        if s.query(Club).filter_by(name=name).first():
            name = f"{name}-{random.randint(10,99)}"
        club = Club(name=name, owner_id=db_user.id, budget=1_000_000, rating=50.0)
        s.add(club)
        s.commit()
        db_user.club_id = club.id
        s.commit()
        # create 11 players
        for i in range(11):
            p = Player(name=f"P{i+1}", club_id=club.id, rating=random.randint(40,70), value=random.randint(50_000,200_000))
            s.add(p)
        s.commit()
    await update.message.reply_text(f"Клуб '{name}' создан! ID: {club.id}")

async def my_team_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    with get_session() as s:
        db_user = s.query(User).filter_by(telegram_id=user.id).first()
        if not db_user or not db_user.club_id:
            await update.message.reply_text("У тебя нет клуба. /register_team")
            return
        club = s.query(Club).get(db_user.club_id)
        players = s.query(Player).filter_by(club_id=club.id).all()
        lines = [f"Клуб: {club.name} (ID {club.id})", f"Бюджет: {club.budget}", f"Рейтинг: {club.rating}", "Игроки:"]
        for p in players:
            lines.append(f"- {p.id}: {p.name} (rating {p.rating}, value {p.value})")
        await update.message.reply_text("\n".join(lines))

async def clubs_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    with get_session() as s:
        clubs = s.query(Club).order_by(Club.rating.desc()).limit(50).all()
        if not clubs:
            await update.message.reply_text("Клубов ещё нет.")
            return
        lines = [f"{c.id}: {c.name} — rating {round(c.rating,1)}, budget {c.budget}" for c in clubs]
        await update.message.reply_text("\n".join(lines))

async def players_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("Использование: /players <club_id>")
        return
    try:
        cid = int(context.args[0])
    except:
        await update.message.reply_text("Неверный ID клуба.")
        return
    with get_session() as s:
        players = s.query(Player).filter_by(club_id=cid).all()
        if not players:
            await update.message.reply_text("У клуба нет игроков или клуб не найден.")
            return
        lines = [f"Игроки клуба {cid}:"]
        for p in players:
            lines.append(f"- {p.id}: {p.name}, rating {p.rating}, value {p.value}")
        await update.message.reply_text("\n".join(lines))

async def challenge_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not context.args:
        await update.message.reply_text("Использование: /challenge <club_id>")
        return
    try:
        opponent_id = int(context.args[0])
    except:
        await update.message.reply_text("Неверный ID соперника.")
        return
    with get_session() as s:
        db_user = s.query(User).filter_by(telegram_id=user.id).first()
        if not db_user or not db_user.club_id:
            await update.message.reply_text("У тебя нет клуба. /register_team")
            return
        home_id = db_user.club_id
        if home_id == opponent_id:
            await update.message.reply_text("Нельзя вызвать свой клуб.")
            return
        now = datetime.datetime.utcnow()
        m = Match(home_club_id=home_id, away_club_id=opponent_id, scheduled_time=now, status="scheduled", is_friendly=True)
        s.add(m)
        s.commit()
        await update.message.reply_text(f"Товарищеский матч создан: {m.id}. Он будет сыгран в ближайшее время.")

async def schedule_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    with get_session() as s:
        upcoming = s.query(Match).filter(Match.status == "scheduled").order_by(Match.scheduled_time).limit(30).all()
        if not upcoming:
            await update.message.reply_text("Нет запланированных матчей.")
            return
        lines = []
        for m in upcoming:
            lines.append(f"Match {m.id}: {m.home_club_id} vs {m.away_club_id} at {m.scheduled_time} (friendly={m.is_friendly})")
        await update.message.reply_text("\n".join(lines))

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "/register_team <name> — создать клуб\n"
        "/my_team — информация о твоём клубе\n"
        "/clubs — список клубов\n"
        "/players <club_id> — показать игроков клуба\n"
        "/challenge <club_id> — сыграть товарищеский матч\n"
        "/schedule — посмотреть запланированные матчи\n"
    )

# ========== STARTUP ==========
def build_and_run_bot():
    if not BOT_TOKEN:
        raise SystemExit("BOT_TOKEN is required in environment to run the bot.")
    create_tables()

    application = ApplicationBuilder().token(BOT_TOKEN).build()
    application.add_handler(CommandHandler("start", start_cmd))
    application.add_handler(CommandHandler("register_team", register_team_cmd))
    application.add_handler(CommandHandler("my_team", my_team_cmd))
    application.add_handler(CommandHandler("clubs", clubs_cmd))
    application.add_handler(CommandHandler("players", players_cmd))
    application.add_handler(CommandHandler("challenge", challenge_cmd))
    application.add_handler(CommandHandler("schedule", schedule_cmd))
    application.add_handler(CommandHandler("help", help_cmd))

    # Scheduler will check every 15 seconds for ready matches
    scheduler = AsyncIOScheduler()
    scheduler.add_job(lambda: asyncio.create_task(process_scheduled_matches()), "interval", seconds=15)
    scheduler.start()

    # Run webhook if WEBHOOK_BASE_URL provided, otherwise run polling (local)
    if WEBHOOK_BASE_URL:
        webhook_url = f"{WEBHOOK_BASE_URL}/{BOT_TOKEN}"
        log.info("Setting webhook to %s", webhook_url)
        application.run_webhook(
            listen="0.0.0.0",
            port=PORT,
            url_path=BOT_TOKEN,
            webhook_url=webhook_url,
        )
    else:
        log.info("Running in polling mode (WEBHOOK_BASE_URL not set).")
        application.run_polling()

if __name__ == "__main__":
    build_and_run_bot()