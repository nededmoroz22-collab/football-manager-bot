#!/usr/bin/env python3
# main.py - single-file minimal football manager bot

import os
import asyncio
import datetime
import random
import logging
from contextlib import contextmanager

# optionally load .env if present
try:
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass

from sqlalchemy import create_engine, Column, Integer, String, Float, Boolean, DateTime
from sqlalchemy.orm import declarative_base, sessionmaker

from apscheduler.schedulers.asyncio import AsyncIOScheduler

from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes

# ---------- CONFIG ----------
BOT_TOKEN = os.environ.get("BOT_TOKEN", "").strip()
DATABASE_URL = os.environ.get("DATABASE_URL", "sqlite:///./dev.db")
PORT = int(os.environ.get("PORT", 5000))
WEBHOOK_BASE_URL = os.environ.get("WEBHOOK_BASE_URL", "").rstrip("/") or None

# ---------- LOGGING ----------
logging.basicConfig(level=logging.INFO)
log = logging.getLogger("football-manager")
log.info("Starting football manager bot")
if not BOT_TOKEN:
    log.warning("BOT_TOKEN is not set. Set BOT_TOKEN env var before running.")

# ---------- DATABASE ----------
Base = declarative_base()
connect_args = {"check_same_thread": False} if DATABASE_URL.startswith("sqlite") else {}
engine = create_engine(DATABASE_URL, connect_args=connect_args, pool_pre_ping=True)
SessionLocal = sessionmaker(bind=engine, expire_on_commit=False)


@contextmanager
def get_session():
    s = SessionLocal()
    try:
        yield s
    finally:
        s.close()


# ---------- MODELS ----------
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    telegram_id = Column(Integer, unique=True, index=True)
    username = Column(String, nullable=True)
    club_id = Column(Integer, nullable=True)


class Club(Base):
    __tablename__ = "clubs"
    id = Column(Integer, primary_key=True)
    name = Column(String, unique=True)
    owner_id = Column(Integer, nullable=True)
    budget = Column(Integer, default=1_000_000)
    rating = Column(Float, default=50.0)


class Player(Base):
    __tablename__ = "players"
    id = Column(Integer, primary_key=True)
    name = Column(String)
    club_id = Column(Integer, nullable=True)
    rating = Column(Integer, default=50)
    value = Column(Integer, default=100_000)


class Match(Base):
    __tablename__ = "matches"
    id = Column(Integer, primary_key=True)
    home_club_id = Column(Integer)
    away_club_id = Column(Integer)
    scheduled_time = Column(DateTime, default=datetime.datetime.utcnow)
    status = Column(String, default="scheduled")  # scheduled / played / cancelled
    home_goals = Column(Integer, default=0)
    away_goals = Column(Integer, default=0)
    is_friendly = Column(Boolean, default=False)


def create_tables():
    Base.metadata.create_all(bind=engine)


# ---------- GAME LOGIC ----------
def compute_club_rating_from_players(players):
    if not players:
        return 35.0
    return sum((p.rating or 0) for p in players) / max(1, len(players))


def simulate_match_logic(home_rating, away_rating):
    diff = home_rating - away_rating
    home_expected = max(0.1, 0.8 + home_rating / 100.0 + diff / 150.0)
    away_expected = max(0.1, 0.8 + away_rating / 100.0 - diff / 150.0)
    hg = max(0, int(round(random.gauss(home_expected, 1.0))))
    ag = max(0, int(round(random.gauss(away_expected, 1.0))))
    return hg, ag


async def process_scheduled_matches():
    now = datetime.datetime.utcnow()
    with get_session() as s:
        matches = s.query(Match).filter(Match.status == "scheduled", Match.scheduled_time <= now).all()
        for m in matches:
            try:
                home_players = s.query(Player).filter(Player.club_id == m.home_club_id).all()
                away_players = s.query(Player).filter(Player.club_id == m.away_club_id).all()
                home_rating = compute_club_rating_from_players(home_players)
                away_rating = compute_club_rating_from_players(away_players)
                hg, ag = simulate_match_logic(home_rating, away_rating)
                m.home_goals = hg
                m.away_goals = ag
                m.status = "played"
                # small rating adjustment
                delta = 1.0 if hg > ag else (-1.0 if hg < ag else 0.2)
                home_club = s.get(Club, m.home_club_id)
                away_club = s.get(Club, m.away_club_id)
                if home_club:
                    home_club.rating = max(1.0, (home_club.rating or 50.0) + delta)
                if away_club:
                    away_club.rating = max(1.0, (away_club.rating or 50.0) - delta)
                s.commit()
                log.info("Played match %s: %s %d-%d %s", m.id, m.home_club_id, hg, ag, m.away_club_id)
            except Exception:
                log.exception("Error processing match %s", getattr(m, "id", "?"))
                s.rollback()


# ---------- BOT HANDLERS ----------
async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    with get_session() as s:
        db_user = s.query(User).filter_by(telegram_id=user.id).first()
        if not db_user:
            db_user = User(telegram_id=user.id, username=user.username or user.full_name)
            s.add(db_user)
            s.commit()
    await update.message.reply_text(
        "Привет! Я футбольный менеджер.\n"
        "/register_team <name> — создать клуб\n"
        "/my_team — показать свой клуб\n"
        "/clubs — список клубов\n"
        "/players <club_id> — показать игроков\n"
        "/challenge <club_id> — сыграть товарищеский матч\n"
        "/schedule — посмотреть запланированные матчи\n"
    )


async def register_team_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    name = " ".join(context.args) if context.args else f"{user.username or user.first_name}'s Club"
    with get_session() as s:
        db_user = s.query(User).filter_by(telegram_id=user.id).first()
        if not db_user:
            db_user = User(telegram_id=user.id, username=user.username or user.full_name)
            s.add(db_user)
            s.commit()
        if db_user.club_id:
            await update.message.reply_text("У тебя уже есть клуб.")
            return
        # ensure unique name
        if s.query(Club).filter_by(name=name).first():
            name = f"{name}-{random.randint(10,99)}"
        club = Club(name=name, owner_id=db_user.id, budget=1_000_000, rating=50.0)
        s.add(club)
        s.commit()
        db_user.club_id = club.id
        s.commit()
        # create 11 players
        for i in range(11):
            p = Player(
                name=f"P{i+1}",
                club_id=club.id,
                rating=random.randint(40, 70),
                value=random.randint(50_000, 200_000),
            )
            s.add(p)
        s.commit()
    await update.message.reply_text(f"Клуб '{name}' создан! ID: {club.id}")


async def my_team_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    with get_session() as s:
        db_user = s.query(User).filter_by(telegram_id=user.id).first()
        if not db_user or not db_user.club_id:
            await update.message.reply_text("У тебя нет клуба. /register_team")
            return
        club = s.get(Club, db_user.club_id)
        players = s.query(Player).filter_by(club_id=club.id).all()
        lines = [
            f"Клуб: {club.name} (ID {club.id})",
            f"Бюджет: {club.budget}",
            f"Рейтинг: {round(club.rating,1)}",
            "Игроки:",
        ]
        for p in players:
            lines.append(f"- {p.id}: {p.name} (rating {p.rating}, value {p.value})")
        await update.message.reply_text("\n".join(lines))


async def clubs_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    with get_session() as s:
        clubs = s.query(Club).order_by(Club.rating.desc()).limit(50).all()
        if not clubs:
            await update.message.reply_text("Клубов ещё нет.")
            return
        lines = [f"{c.id}: {c.name} — rating {round(c.rating,1)}, budget {c.budget}" for c in clubs]
        await update.message.reply_text("\n".join(lines))


async def players_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("Использование: /players <club_id>")
        return
    try:
        cid = int(context.args[0])
    except Exception:
        await update.message.reply_text("Неверный ID клуба.")
        return
    with get_session() as s:
        players = s.query(Player).filter_by(club_id=cid).all()
        if not players:
            await update.message.reply_text("Игроков нет или клуб не найден.")
            return
        lines = [f"Игроки клуба {cid}:"]
        for p in players:
            lines.append(f"- {p.id}: {p.name}, rating {p.rating}, value {p.value}")
        await update.message.reply_text("\n".join(lines))


async def challenge_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not context.args:
        await update.message.reply_text("Использование: /challenge <club_id>")
        return
    try:
        opponent_id = int(context.args[0])
    except Exception:
        await update.message.reply_text("Неверный ID соперника.")
        return
    with get_session() as s:
        db_user = s.query(User).filter_by(telegram_id=user.id).first()
        if not db_user or not db_user.club_id:
            await update.message.reply_text("У тебя нет клуба. /register_team")
            return
        home_id = db_user.club_id
        if home_id == opponent_id:
            await update.message.reply_text("Нельзя вызвать свой клуб.")
            return
        now = datetime.datetime.utcnow()
        m = Match(
            home_club_id=home_id,
            away_club_id=opponent_id,
            scheduled_time=now,
            status="scheduled",
            is_friendly=True,
        )
        s.add(m)
        s.commit()
    await update.message.reply_text(f"Товарищеский матч создан: {m.id}. Он будет сыгран в ближайшее время.")


async def schedule_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    with get_session() as s:
        upcoming = s.query(Match).filter(Match.status == "scheduled").order_by(Match.scheduled_time).limit(30).all()
        if not upcoming:
            await update.message.reply_text("Нет запланированных матчей.")
            return
        lines = [
            f"Match {m.id}: {m.home_club_id} vs {m.away_club_id} at {m.scheduled_time} (friendly={m.is_friendly})"
            for m in upcoming
        ]
        await update.message.reply_text("\n".join(lines))


async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "/register_team <name>\n"
        "/my_team\n"
        "/clubs\n"
        "/players <club_id>\n"
        "/challenge <club_id>\n"
        "/schedule\n"
        "/help"
    )


# ---------- RUN ----------
def run_bot():
    if not BOT_TOKEN:
        raise SystemExit("Set BOT_TOKEN environment variable and restart.")

    create_tables()

    app = ApplicationBuilder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("register_team", register_team_cmd))
    app.add_handler(CommandHandler("my_team", my_team_cmd))
    app.add_handler(CommandHandler("clubs", clubs_cmd))
    app.add_handler(CommandHandler("players", players_cmd))
    app.add_handler(CommandHandler("challenge", challenge_cmd))
    app.add_handler(CommandHandler("schedule", schedule_cmd))
    app.add_handler(CommandHandler("help", help_cmd))

    # Scheduler: check every 15 seconds for matches to play
    scheduler = AsyncIOScheduler()
    scheduler.add_job(lambda: asyncio.create_task(process_scheduled_matches()), "interval", seconds=15)
    scheduler.start()

    # If WEBHOOK_BASE_URL present, register webhook; otherwise use polling
    if WEBHOOK_BASE_URL:
        webhook_url = f"{WEBHOOK_BASE_URL}/{BOT_TOKEN}"
        log.info("Setting webhook to %s", webhook_url)
        app.run_webhook(
            listen="0.0.0.0",
            port=PORT,
            url_path=BOT_TOKEN,
            webhook_url=webhook_url,
        )
    else:
        log.info("Running in polling mode.")
        app.run_polling()


if __name__ == "__main__":
    run_bot()
